#!/usr/bin/python3
#
# Maximilian Wilhelm <max@sdn.clinic>
#  --  Mon 01 Apr 2024 17:55:42 CET
#
import ipaddress
from typing import Optional, Tuple

from nacl.modules import BaseModule
from nacl.sorthelper import sort_interface_list

# Node roles which indicate that a given node is running a DHCP server.
# Used to determine if this module should be run for a given node.
DHCP_SERVER_ROLES = [
    "batman_gateway",
    "dhcp-server",
    "edge_router",
]

# Prefix attributes to copy over from a prefix queried from NetBox/Nacl
PREFIX_ITEMS = [
    "description",
    "prefix",
    "role",
    "status",
]


def prefix_is_relevant(pfx: dict, minion_id: str) -> bool:
    if pfx["family"] != 4:
        return False

    if not pfx.get("dhcp_enabled", False):
        return False

    batman_gw = pfx.get("batman_gateway")
    if batman_gw and batman_gw != minion_id:
        return False

    return True

def our_IP_in_prefix(pfx: ipaddress.ip_network, ifaces: dict) -> Optional[Tuple[str,str]]:
    """Check all interface IPs if they are part of the given prefix and return the IP, if so.

    Parameters
    ----------
    pfx: str
        The prefix to check for.
    ifaces: dict
        The interfaces configuration of the given node.

    Returns
    -------
    str, str
        Return the interface and IP (without prefix length) if a match is found.
        If no match is found, None, None is returned.
    """
    for iface, iface_cfg in ifaces.items():
        for ip in iface_cfg.get("prefixes", []):
            ip_obj = ipaddress.ip_network(ip, strict=False)
            # Ignore any IPv6 addresses
            if ip_obj.version == 6:
                continue

            if ip_obj.subnet_of(pfx):
                return iface, ip.split("/")[0]

    return None, None

def sort_dhcp_prefixes(pfxs: list[dict]) -> None:
    sorted(pfxs, key=lambda pfx: pfx['network'])

    for pfx in pfxs:
        pfx["network"] = str(pfx["network"])


class Module(BaseModule):
    def should_run (self, node_config) -> bool:
        """Returns whether this module should run for the given node_config.

        Parameters
        ----------
        node_config:
            A node_config dict containing the NACL node configuration generated so far.

        Returns
        -------
        bool:
            Whether the given node is running a DHCP server and hence needs configuration.
        """
        our_roles = node_config.get("roles", [])
        return len(set(DHCP_SERVER_ROLES) & set(our_roles)) > 0

    def run (self, nodes: dict, minion_id: str) -> Optional[dict]:
        """Execute the module for the given node_id.

        Parameters
        ----------
        nodes:
            A dictionary containing all node_configs by their respective minion_id.

        minion_id:
            The Salt minion ID of the minion we should compute the configuraton for.

        Returns
        -------
        dict, optional:
            A dictionary containing the configuration items generated by this module.
            This module will return a dictionary with the `dhcp.server.prefixes` key,
            or None if no configuration has been generated.
        """
        nb_prefixes = self.nacl.get_prefixes()
        potential_prefixes = [pfx for pfx in nb_prefixes if prefix_is_relevant(pfx, minion_id)]
        self.log.debug(f"Found {len(nb_prefixes)} prefixes in NetBox, investigating {len(potential_prefixes)}.")

        dhcp_prefixes = []
        ifaces = set()

        for pfx in potential_prefixes:
            # Find the local interface and IP related to this prefix.
            # If the local device does not have an interface into this prefix, it won't be a DHCP server.
            pfx_obj = ipaddress.ip_network(pfx["prefix"], strict = False)
            iface, ip = our_IP_in_prefix(pfx_obj, nodes[minion_id]["ifaces"])
            if not iface:
                continue

            new_pfx = {
                "network": pfx_obj.network_address, # Will be stringified after sorting
                "netmask": str(pfx_obj.netmask),
                "iface": iface,
                "routers": ip,
            }
            for item in PREFIX_ITEMS:
                new_pfx[item] = pfx.get(item)

            # Usually we will have a range, however there might be prefixes with static leases only.
            range = pfx.get("dhcp_range")
            if range:
                new_pfx["range"] = range

            ifaces.add(iface)
            dhcp_prefixes.append(new_pfx)

        if not dhcp_prefixes:
            return None

        sort_dhcp_prefixes(dhcp_prefixes)

        return {
            "dhcp.server.ifaces": sort_interface_list(list(ifaces)),
            "dhcp.server.prefixes": dhcp_prefixes,
        }
