#!/usr/bin/python3
#
# Maximilian Wilhelm <max@sdn.clinic>
#  --  Thu 15 Feb 2024 10:51:33 PM CET
#

from typing import Optional
import ipaddress
import re

from nacl.modules import BaseModule, ModuleError

base_ports = {
    "wg" : 50000,
    "oob" : 51000,
}

class Module(BaseModule):
    def should_run(self, node_config) -> bool:
        """Returns whether this module should run for the given node_config.

        Parameters
        ----------
        node_config:
            A node_config dict containing the NACL node configuration generated so far.

        Returns
        -------
            bool
        """
        # Wireguard private key set for this node? If not, there's nothing to be done here
        try:
            node_privkey = node_config["wireguard"]["privkey"]
        except KeyError:
            return False

        return True

    def run(self, nodes: dict, minion_id: str) -> Optional[dict]:
        """Execute the module for the given node_id.

        Parameters
        ----------
        nodes:
            A dictionary containing all node_configs by their respective minion_id.

        minion_id:
            The Salt minion ID of the minion we should compute the configuraton for.

        Returns
        -------
        dict, optional:
            A dictionary containing the configuration items generated by this module.
            Items are identified by a hierarchical key with elements separated by dots,
            e.g. routing.bgp.internal.peers or wireguard.
            A return value of None may be used to indicate that no configuration has been generated.
        """
        node = nodes[minion_id]
        tunnels = {}

        # Wireguard private key set for this node? If not, there's nothing to be done here
        try:
            node_privkey = node['wireguard']['privkey']
        except KeyError:
            raise ModuleError(f"No wireguard private key found for {minion_id}")

        for iface, iface_cfg in node['ifaces'].items ():
            # Get Wireguard public from peer, if present
            try:
                peer_fqdn = iface_cfg['wireguard']['peer']
                peer_node = nodes[peer_fqdn]
                peer_pubkey = peer_node['wireguard']['pubkey']
            except KeyError:
                continue

            # Get public IP of peer
            peer_ip = None
            for peer_iface, peer_iface_cfg in peer_node['ifaces'].items ():
                if not peer_iface_cfg.get('vrf') == 'vrf_external':
                    continue

                for ip_cidr in peer_iface_cfg['prefixes']:
                    ip = ipaddress.ip_address(ip_cidr.split ('/')[0])
                    if ip.version == 4:
                        peer_ip = str(ip)

            # Calculate Wireguard port based on the IPv6 subnet assigned to the tunnel.
            # We use 2a03:2260:2342:fd00::/56 for all VPN PTP links and just use the 8 bits
            # from /56 to /64 as index and 52000 as base.
            try:
                base_port = base_ports[iface.split("-")[0]]
            except KeyError:
                raise ModuleError(f"No base port found for interface {iface}")

            port = None
            for ip_cidr in iface_cfg['prefixes']:
                ip = ipaddress.ip_address(ip_cidr.split('/')[0])
                if ip.version == 6:
                    port = base_port + int(str(ip).split(':')[3][2:], 16)
                    break

            if not port:
                continue

            # By default we assume we are a client and should connect to the peer
            mode = 'client'

            # If we are a core router however, and the peer is not, we are serer
            if minion_id.startswith('cr') and not peer_fqdn.startswith('cr'):
                mode = 'server'

            # If we are a core router and the peer is too, the one with the lower ID is server
            local_match = re.search('^cr(\d+).*$', minion_id)
            peer_match = re.search('^cr(\d+).*$', peer_fqdn)
            if local_match and peer_match and int(local_match.group (1)) < int(peer_match.group (1)):
                mode = 'server'

            # By default our tunnels are established via VRF external, which we
            # target via the fwmark of 0x1023. For OOBM VPNs we want to use a
            # different VRF (vrf_oobm_ext), which we can target via fwmark 0x1101.
            # OOBM VPNs only need to use vrf_oobm_ext on the client device and use
            # the regular external VRF on the server side.
            fwmark = "0x1023"
            if mode == 'client' and iface.startswith('oob-'):
                fwmark = "0x1101"

            tunnels[iface] = {
                "peer_fqdn" : peer_fqdn,
                "peer_pubkey" : peer_pubkey,
                "peer_ip" : peer_ip,
                "port" : port,
                "mode" : mode,
		"fwmark" : fwmark,
            }

        if tunnels:
            return {
                "wireguard.tunnels": tunnels,
            }

        return None
